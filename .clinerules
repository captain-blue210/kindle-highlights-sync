# Project Guidelines

## 基本ルール

- ユーザーとのやり取りは**日本語**で行うこと
- ドキュメントの更新は**日本語**で行うこと

## 1. コード品質とテスト

- **テスト駆動とカバレッジ:**
- すべての機能変更には対応するユニットテスト（Vitest）を追加し、コード変更時には必ずテストが網羅されるようにします。コミット前に全テストがパスすることを確認してください。
- **テストファイル命名:**
- テストファイルは `*.test.ts` または `*.spec.ts` というサフィックスを付けて命名し、本体コードと同じディレクトリか専用の `__tests__` ディレクトリに配置します。こうすることでテストが自動検出され、関連コードを容易に確認できます。
- **テストケースの記述:**
- テストケース名は挙動を明確に表す記述的なものにし、1つのテストでは単一の機能やシナリオに焦点を当てます。

## 2. コードスタイルとフォーマット

- **コードフォーマット統一:**
- Prettier などのフォーマッターを用いて、コードのスタイルを自動整形します。コミット時に自動整形を実行し、全員が同じフォーマット規則に従うようにします。
- **Lint 規則遵守:**
- ESLint（TypeScript/React 用の推奨ルールを含む）を導入し、潜在バグやスタイル違反を検出します。特別な理由がない限り ESLint のルールを無効化しないようにし、コードベース全体で一貫した品質基準を守ります。
- **TypeScript 厳格モード:**
- `strict` オプションを有効にし、可能な限り `any` 型の使用を避けます。型定義（インターフェースや型エイリアス）を活用してコードの意図を明確化し、型安全性を担保します。
- **React ベストプラクティス:**
- React コンポーネントは関数コンポーネントとし、フックを用いた状態管理を行います。クラスコンポーネントは新規開発では使用せず、React Hooks に統一します。また、副作用のある処理は適切にクリーンアップし、メモリリークや不要な再レンダリングを防ぎます。

## 3. ディレクトリ構成と命名規則

- **プロジェクト構成:**
- Next.js の推奨に従い、`app/`（または従来の `pages/`）ディレクトリをルーティングに使用し、`public/` 配下に静的ファイルを配置します。可能であればすべてのソースコードを `src/` ディレクトリ以下に置き、設定ファイルやCI設定と明確に分離します。
- **機能別の整理:**
- コンポーネントやフック、ユーティリティは機能ごと・ドメインごとにフォルダを分けて整理します。例えば、`src/components/`、`src/hooks/`、`src/utils/` といった構成とし、関連するファイルが近くにまとまるようにします。将来的にプロジェクトが大規模化しても、この整理により目的のコードを素早く見つけられます。
- **ファイル命名:**
- 一貫した命名規則を適用します。React コンポーネントのファイル名・クラス名は PascalCase（例：`MyComponent.tsx`）、通常のスクリプトやスタイルシートはケバブケースまたはスネークケース（例：`data-fetcher.ts` や `api_client.ts`）で命名します。ファイル名と内部のエクスポート名（コンポーネント名など）を一致させ、可読性を高めます。
- **テストファイル配置:**
- テストコードは対応するソースコードの近くに配置するか、プロジェクトルート直下に `tests/` ディレクトリを設けます。Next.js を使用する場合、テストファイルがビルドやルーティングに影響しないよう、`pages` ディレクトリの外または `__tests__` フォルダ内に配置します。


## 4. セキュリティと環境変数の管理

- **シークレット管理:**
- APIキーや機密情報は**絶対に**リポジトリに含めません。`.env.local` などの環境変数ファイルに記述し、これらのファイルは `.gitignore` に追加してGit管理から除外します。また、必要に応じて `.env.example` ファイルを用意し、開発者が必要な環境変数の種類を把握できるようにします。
- **環境変数の利用:**
- 環境変数を使って設定値やシークレットを注入します。Next.js では、クライアント側で利用する環境変数には名前に `NEXT_PUBLIC_` プレフィックスを付与する必要があります（これが付いた変数のみクライアントに露出されます）。サーバー専用のシークレットはプレフィックスなしで `.env` に定義し、クライアントには渡さないようにします。
- **CI/CD 上のシークレット:**
- CI/CD（GitHub Actions など）では、リポジトリのシークレット機能や Vercel の環境変数設定を活用して機密情報を渡します。プログラム中に直書きする代わりに、CI 上では自動で適切な環境変数が読み込まれるよう設定し、ログ等に出力されないよう注意します。
- **依存関係と脆弱性:**
- パッケージは定期的にアップデートし、`npm audit` や Dependabot などを用いて既知のセキュリティ脆弱性がないかチェックします。不審な依存関係は導入しないようにし、必要がなくなったパッケージは削除します。


## 5. CI/CD とデプロイ

- **テスト自動化と品質ゲート:**
- 継続的インテグレーション（CI）環境を構築し、すべてのプッシュやプルリクエストで自動的にビルドとテスト、Lint チェックを実行します。テストやLintに失敗した場合はマージやデプロイが行われないようにして、品質を保証します。 
- **GitHub Actions/Vercel 連携:**
- GitHub Actions などでCIパイプラインを設定し、`main` ブランチへのプッシュ時にユニットテスト・ビルド・デプロイを自動実行します。Vercel と連携して、テスト通過後に本番環境へ自動デプロイするなど、CI/CD の一連の流れを整備します。
- **コードフォーマット検証:**
- CI 上でもコードフォーマットやLintをチェックし、規約違反がないか検証します（必要に応じて `lint-staged` や `husky` を用いてコミット時に自動修正）。チーム開発ではプルリクエストに自動チェック結果を表示し、レビュー時にフォーマットの指摘が不要になるようにします。 
- **バージョン管理とリリース:**
- 本番リリース用のブランチ戦略を決め（例：GitHub Flow もしくは GitFlow のような運用）、タグ付けやリリースノートの自動生成などCI/CDで管理できるものは自動化します。これによりデプロイ作業の属人化を避け、リリースの再現性を高めます。


## 6. 拡張性と将来のスケーラビリティ

- **モジュール化と疎結合:**
- アプリケーションを機能ごとに適切にモジュール分割し、各部分が高凝集・低結合になるよう設計します。モジュール間は明確なインターフェース越しにやりとりするようにし、副作用を最小限に抑えます。このアプローチにより、将来必要になった際に特定の機能を別パッケージやサービスに切り離しやすくなります。
- **将来の monorepo 化:**
- プロジェクトが拡大した場合に monorepo 構成（複数パッケージを1リポジトリで管理）へ移行できるよう、ディレクトリ構成に柔軟性を持たせておきます。例えば、共通ライブラリ的なコードは `libs/` ディレクトリに分離しておく、複数のアプリケーションを想定して `apps/` ディレクトリを用意する、といった工夫です。現在は単一プロジェクトでも、このような構成を意識しておくことで、後からリポジトリを分割せずにパッケージ追加が可能になります。
- **マイクロサービスへの備え:**
- 将来的にサービスを独立展開（マイクロサービス化）する場合を見据え、ドメイン境界ごとにコードを整理します。特にデータアクセスやビジネスロジックはUIから分離し、例えば API 層・サービス層・UI 層といったレイヤーアーキテクチャを意識します。こうしておけば、特定のドメインを別サービスに切り出す際にも、依存関係を把握しやすくリファクタリングコストを下げられます。    
- **ドキュメントとガイド:**
- アーキテクチャや設計の決定事項は README や `/docs` ディレクトリなどに記録します。将来的にチーム開発やプロジェクトの再構成を行う際、その記録が指針となりスムーズに知識共有できます。


## 7. 関数型プログラミングのベストプラクティス

- **純粋関数を使用**: 副作用を避け、同じ入力に対して常に同じ出力を返す。
- **イミュータビリティを守る**: データを直接変更せず、新しいインスタンスを作成。
- **高階関数を活用**: `map`, `filter`, `reduce` などを積極的に使用。
- **関数の合成**: 小さな関数を組み合わせて複雑な処理を構築。
- **副作用を管理**: API呼び出しやDOM操作は分離し、予測可能性を維持。


## 8. コミットメッセージのベストプラクティス

- **形式を統一**: `type(scope): message` の形式を使用。
- `type` 例: `feat`, `fix`, `chore`, `docs`, `refactor`, `test`
- `scope` 例: `auth`, `api`, `ui`, `ci`
- **例:** `feat(auth): add login functionality`
- **明確な説明**: 何を変更したか・なぜ変更したかを簡潔に記述。
- **変更の粒度**: 1コミット1目的を原則とし、複数の目的を含めない。
- **動詞の原形**: コミットメッセージは `Add`, `Fix`, `Update` などの動詞を使用。
- **Issueの関連付け**: 必要に応じて `#issue番号` を本文に記載。

**例:**
fix(auth): correct login validation issue

- Fixed input validation for login form
- Related to #42

## 9. AI とのやりとりの保存

- **AI 対話ログの保存:** すべての AI とのやり取りは `docs/prompt-logs/` 配下に保存する。    
- **ファイル命名規則:** `YYYY-MM-DD_HH-MM-SS_log.md` の形式で命名する。
- **保存の目的:** プロンプトとレスポンスの記録は、意思決定の透明性とプロジェクト履歴の参照を容易にするため。
